#ifndef PAIR_HPP
# define PAIR_HPP

namespace ft
{
	template <class T1, class T2>
	struct pair
	{
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/// type definitions
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		typedef T1 first_type;
		typedef T2 second_type;
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/// type definitions End
		/////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/// destructors, constructors, and assignment operators
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		pair()
		{
		}

		pair(const first_type& a, const second_type& b) : first(a), second(b)
		{
		}

		template<class U, class V>
		pair(const pair<U,V>& pr) : first(pr.first), second(pr.second)
		{
		}

		pair	&operator=(const pair& pr)
		{
			if (this == &pr)
				return *this;
			first = pr.first;
			second = pr.second;
			return *this;
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/// destructors, constructors, and assignment operators End
		/////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/// relational operators
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		friend bool	operator==(const pair<T1,T2>& lhs, const pair<T1,T2>& rhs)
		{
			if (lhs.first != rhs.first)
				return false;
			return lhs.second == rhs.second;
		}

		friend bool	operator!=(const pair<T1,T2>& lhs, const pair<T1,T2>& rhs)
		{
			return !(lhs == rhs);
		}

		friend bool	operator<(const pair<T1,T2>& lhs, const pair<T1,T2>& rhs)
		{
			if (lhs.first < rhs.first)
				return true;
			return lhs.first == rhs.first && lhs.second < rhs.second;
		}

		friend bool	operator<=(const pair<T1,T2>& lhs, const pair<T1,T2>& rhs)
		{
			return !(rhs < lhs);
		}

		friend bool	operator>(const pair<T1,T2>& lhs, const pair<T1,T2>& rhs)
		{
			return rhs < lhs;
		}

		friend bool	operator>=(const pair<T1,T2>& lhs, const pair<T1,T2>& rhs)
		{
			return !(lhs < rhs);
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/// relational operators End
		/////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/// Data members
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		first_type	first;
		second_type	second;
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		/// Data members
		/////////////////////////////////////////////////////////////////////////////////////////////////////
	};
}

#endif